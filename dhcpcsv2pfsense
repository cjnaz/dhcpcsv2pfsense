#!/usr/bin/env python3
"""Merge DHCP static assignments .csv data into pfSense DHCP Server config file.
"""

__version__ = "V0.1 211009"


#==========================================================
#
#  Chris Nelson, 2021
#
# V0.1 211009  Bug fix for row ignore based on first column blank.  Properly carry over the real postamble and block indentation.
# V0.0 211007  New
#
# Changes pending
#   
#==========================================================

import argparse
import sys
import os.path
import io
import glob
import csv
import logging

# Configs / Constants
PY_MIN_VERSION = 3.6


py_version = float(sys.version_info.major) + float(sys.version_info.minor)/10
if py_version < PY_MIN_VERSION:
    print (f"Current Python version {py_version} is less than minimum required version {PY_MIN_VERSION} - Aborting")
    sys.exit()


def main():

    staticmap_template, indent = get_template()


    with io.open(args.CSV_master_list, newline='', encoding="utf-8") as csvfile:
        csv_table = csv.DictReader(csvfile, dialect="excel")

        # Check that CSV file column names map to <staticmap> fields
        valid_columns = []
        for colname in csv_table.fieldnames:
            if colname not in staticmap_template:
                logging.info(f"Warning:  CSV file column name {colname} not found in the <staticmap> template.  This column will be ignored.")
            else:
                valid_columns.append(colname)

        with io.open (in_config_file, "r", encoding="utf-8") as ifile:
            with io.open (out_config_file, "wt", encoding="utf-8") as ofile:

                # Copy the input backup file preamble up to the first <staticmap>
                in_file_buf = ifile.read().split("\n")
                for line in in_file_buf:
                    if "<staticmap>" not in line:
                        ofile.write(line + "\n")
                    else:
                        break

                # Dispose of existing <staticmap> blocks and capture the file postamble
                postamble = ""
                for line in in_file_buf:
                    if "</staticmap>" not in line:
                        postamble += line  + "\n"
                    else:
                        postamble = ""

                # Create <staticmap> blocks per the CSV rows
                numrows = 0
                for row in csv_table:
                    logging.debug(row)

                    if row[csv_table.fieldnames[0]] != "":  # Allow for blank rows
                        numrows += 1
                        temp_template = ""
                        for line in staticmap_template.split("\n"):
                            lineout = line + "\n"
                            for col in valid_columns:
                                if f"<{col}>" in line:
                                    lineout = f"{indent}\t<{col}>{row[col]}</{col}>\n"
                            temp_template += lineout
                        logging.debug(temp_template)

                        ofile.write(temp_template)

                # Output the postamble
                ofile.write(postamble)

                logging.info(f"Processed {numrows} DHCP static assignments.")


def get_template():
    """ Extract the first <staticmap> block as a template from the input .xml file.
    Return 
        The template block from the first <staticmap> to </staticmap>
        The indentation string before <staticmap>
    """
    template = ""
    with io.open(in_config_file, "r", encoding="utf-8") as ifile:
        line = ifile.readline()
        while "<staticmap>" not in line:
            line = ifile.readline()
        indentation = line[0:-len(line.lstrip())]
        while "</staticmap>" not in line:
            template += line
            line = ifile.readline()
        template += f"{indentation}</staticmap>"
    return template, indentation
            

if __name__ == '__main__':
    parser = argparse.ArgumentParser(description=__doc__ + __version__, formatter_class=argparse.RawTextHelpFormatter)
    parser.add_argument('Config_backup',
                        help="Path to dhcpd-config...xml backup.  If to dir then use most recent file.  If to file then use that specific file.")
    parser.add_argument('CSV_master_list',
                        help="Path to CSV master list file")
    parser.add_argument('-v', '--verbose', action='count',
                        help="Print status and activity messages.")
    parser.add_argument('-V', '--version', action='version', version='%(prog)s ' + __version__,
                        help="Return version number and exit.")

    args = parser.parse_args()

    logging.basicConfig(format='%(message)s')

    if args.verbose is not None:
        if args.verbose == 1:
            logging.getLogger().setLevel(logging.INFO)
        if args.verbose == 2:
            logging.getLogger().setLevel(logging.DEBUG)

    logging.info(__doc__ + __version__)

    if os.path.isdir(args.Config_backup):
        list_of_files = glob.glob(f'{args.Config_backup}/dhcpd-config*.xml')
        in_config_file = max(list_of_files, key=os.path.getctime)
    elif os.path.isfile(args.Config_backup):
        in_config_file = args.Config_backup

    if not os.path.exists(in_config_file):
        logging.error(f"Error:  Input argument Config_backup {args.Config_backup} is not a valid path to a file or directory.")
        sys.exit()

    logging.info (f"Using config backup input file    <{in_config_file}>")

    vnum = 1
    while 1:
        if os.path.exists(in_config_file + f"-csv{vnum}"):
            vnum += 1
        else:
            break

    out_config_file = in_config_file + f"-csv{vnum}"
    logging.info (f"Using config backup output file   <{out_config_file}>")

    if not os.path.exists(args.CSV_master_list):
        logging.error(f"Error:  Input argument CSV_master_list {args.CSV_master_list} is not a valid file path.")
        sys.exit()

    logging.info (f"Using CSV master list input file  <{args.CSV_master_list}>")


    main()
    sys.exit()